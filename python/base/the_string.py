#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# 最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255）
# 由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。
# 但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。
# 你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。
# 因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。
# 现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。
# 但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。
# UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：

# 在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言
# Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符
print('01.', ord('A'))
print('02.', chr(65))
print('03.', ord('珠'))
print('04.', hex(29664))
print('05.', '\u73e0')

# Python对bytes类型的数据用带b前缀的单引号或双引号表示：
b = b'ABC'
print('06.', b)
# 虽然内容显示得和str一样，但bytes的每个字符都只占用一个字节
print('07.', 'ABC'.encode('ascii'))
# 以Unicode表示的str通过encode()方法可以编码为指定的bytes
# str和bytes互相转换时，需要指定编码
print('08.', '珠海'.encode('utf-8'))
# 如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：
print('09.', b'\xe7\x8f\xa0\xe6\xb5\xb7'.decode('utf-8'))
# 可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。
print('10.', len('珠海'.encode('utf-8')))
print('11.', len('珠海'))

# 当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# 在Python中，采用的格式化方式和C语言是一致的，用%实现
# %运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。
print('12.','Hi %s, your score is %d.'%('Bart',59))
''' 常见的占位符有：
%d	整数
%f	浮点数
%s	字符串
%x	十六进制整数 '''
# 格式化整数和浮点数还可以指定是否补0和整数与小数的位数：
print('13.','%4d-%02d-%02d'%(2017,9,27))
print('14.','%.2f'%30)
# 字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%：
print('15.','Progress complete %d%%.'%100)