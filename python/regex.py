#!/usr/bin/env python3
# -*- coding: utf-8 -*-
'正则表达式'

# 用\d可以匹配一个数字，\w可以匹配一个字母或数字
# \s可以匹配一个空格（也包括Tab等空白符）
# .可以匹配任意字符
# 要匹配变长的字符，在正则表达式中，用*表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符：
# 由于'-'是特殊字符，在正则表达式中，要用'\'转义
# 要做更精确地匹配，可以用[]表示范围
# [0-9a-zA-Z\_]可以匹配一个数字、字母或者下划线
# [a-zA-Z\_][0-9a-zA-Z\_]*可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；
# [a-zA-Z\_][0-9a-zA-Z\_]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。
# A|B可以匹配A或B
# ^表示行的开头，^\d表示必须以数字开头
# $表示行的结束，\d$表示必须以数字结束
# py也可以匹配'python'，但是加上^py$就变成了整行匹配，就只能匹配'py'了。
# 用()表示的就是要提取的分组（Group）


# re模块
# 有了准备知识，我们就可以在Python中使用正则表达式了。Python提供re模块，包含所有正则表达式的功能。
# 强烈建议使用Python的r前缀，就不用考虑转义的问题
import re
v=re.match(r'^\d{3}-\d{3,8}$','010-12345')
print('01.',v)
v=re.match(r'^\d{3}-\d{3,8}$','010 12345')
print('02.',v)
# match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None


# 切分字符串
l='a b    c'.split(' ')
print('03.',l)
l=re.split(r'\s+','a b    c')
print('04.',l)
# 无论多少个空格都可以正常分割。加入,试试：
l=re.split(r'[\s,]+','a b ,, c, d')
print('05.',l)

# 分组
m=re.match(r'^(\d{3})-(\d{3,8})$','010-12345')
print('06.',m.group(0))
print('07.',m.group(1))
print('08.',m.group(2))
print('09.',m.groups())
# 如果正则表达式中定义了组，就可以在Match对象上用group()方法提取出子串来。
# 注意到group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串。

# 贪婪匹配
# 最后需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。
m=re.match(r'^(\d+)(0*)$','102300')
print('10.',m.groups())
# 加个?就可以让\d+采用非贪婪匹配
m=re.match(r'^(\d+?)(0*)$','102300')
print('11.',m.groups())

# 编译
# 当我们在Python中使用正则表达式时，re模块内部会干两件事情：
# 编译正则表达式，如果正则表达式的字符串本身不合法，会报错；
# 用编译后的正则表达式去匹配字符串。
# 如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：
re_telephone=re.compile('^(\d{3})-(\d{3,8})$')
print('12.',re_telephone.match('010-12345').groups())
print('13.',re_telephone.match('010-8086').groups())
# 编译后生成Regular Expression对象，由于该对象自己包含了正则表达式，所以调用对应的方法时不用给出正则字符串。
