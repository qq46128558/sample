## 时间复杂度

* n寸面包，每3天吃掉1寸，吃完要3n天，记作T(n)=3n
* n寸面包，每5天吃掉一半，剩1寸要5logn，记作T(n)=5logn
* n寸面包，每2天吃掉1个鸡腿，吃完鸡腿要2天，记作T(n)=2
* n寸面包，第1寸1天，第二个1寸2天，第三个1寸3天，吃完要1+2+3+...+n-1+n=0.5n^2+0.5n，记作T(n)=0.5n^2+0.5n

若存在函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于0的常数，则称f(n)是T(n)的同数量级函数。

记作T(n)=O(f(n))，称O(f(n))为算法的渐进时间复杂度，简称时间复杂度。

推导出时间复杂度的原则：

* 如果运行时间是常数量级，用常数1表示
* 只保留时间函数中的最高阶项
* 如果最高阶项存在，则省去最高阶项前面的系数

* T(n)=3n，时间复杂度为O(n)
* T(n)=5logn，O(logn)
* T(n)=2，O(1)
* T(n)=0.5n^2+0.5n，O(n^2)

* O(1)<O(logn)<O(n)<O(n^2)

## 快速排序

快速排序[O(nLogn)]是从冒泡排序[O(n^2)]演变而来的算法，但是比冒泡排序高效，使用了分治法。也属于交换排序。

冒泡排序在每一轮只把一个元素冒泡到数列的一端

快速排序在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比他小的元素移动到数列另一边，从而把数列拆解成了两个部分。

* 挖坑法
* 指针交换法


## 如何判断一个数是否在40亿个整数中？

* 一个整数4个字节,一个字节8位(1111 1111)
* 4字节x8位=32位(32个1), 4294967295(2^32-1)
* 10亿字节(1,000,000,000byte)为1G
* 40亿个整数,则40亿x4字节=160亿字节,即需要16G
* 判断一个数存在不存在只有两个状态,所以可以用一个位来代表
	* bitmap算法(大数据算法,用位来表示状态)
	* 2^32=4294967296,所以可以申请2^32个位
	* 一个字节8位,2^32/8(2^3)=536870912字节(2^29),即约500M空间即可

## 如何实现可以获取最小值的栈？

* 我现在需要实现一个栈，这个栈除了可以进行普通的push、pop操作以外，还可以进行getMin的操作，getMin方法被调用后，会返回当前栈的最小值，你会怎么做呢？你可以假设栈里面存的都是int整数。
* 一个data栈,一个mins辅助栈
* mins栈存依次入栈的最小值的索引
	* 2 1 2 3 4 1 1 1 6 依次入栈
		* data: 2 1 2 3 4 1 1 1 6
		* mins: 0 1
* push(2)
	* data: 2
	* mins: 0
* push(1)
	* data: 2 1
	* mins: 0 1
* push(1)
	* data: 2 1 1
	* mins: 0 1
* pop()
	* data: 2 1
	* mins: 0 1 (索引为2,mins不动)
* getMin()
	* mins栈顶为1,找data索引1的值1返回

## 热搜排行榜原型

每个被搜索的词条都是一个结构体，所有的被搜索词条构成了一个结构体数组，也就是一个线性结构。被搜索词条这个结构体中有两个成员变量，一个是用于存放搜索次数的整形变量sum，sum要被赋初值为0；另一个是用于存放关键词的字符串key。

将每次用户的输入分成两种情况，第一种情况是之前已经被搜索过的关键词，第二种情况则是之前从来没有被搜索过的关键词。若是第一种情况则让该词条的搜索次数自加1；若是第二种情况则要将新的用户输入作为新词条存储到由被搜索词条构成的结构体数组中，并让该新词条的搜索次数自加1，此时该新词条的搜索次数由初始化后的0变为1。

运用选择排序法或者其他排序算法根据搜索次数由多到少将词条进行排序

## 如何通过编程解决华容道问题？

* 搜索(brute暴力搜索),可以进行搜索的方向

* 剪枝(不再去搜索一些明显不对的方向)

* 回溯(回退),当前面没有路的时候，我们就需要返回来，找到之前有可能出现岔路口的地方，再去下一个方向进行搜索

上面3个步骤是一个比较完整的搜索过程,空格在华容道中移动，就好像我在迷宫里走动一样，每次到一个新的状态，就有几个方向可以搜索，如果是之前碰到过的状态，那就不搜索;

走不通不一定是没路的时候,如果前面的路是之前走过的,也不应该再往前走了,应该回溯

**递归实现回溯**

“回溯”的过程有点像栈的操作。往前走一步就像是入栈，到了死胡同，要往回退，就像是出栈。这个过程确实是栈的过程，但是直接用栈的话，对于你刚刚接触搜索算法，可能编码比较难。其实你可以用递归来实现这个搜索过程. 其实递归在计算机内部也是栈来实现.

* 记录移动路径，其实就是在真正搜索之前，把方向记录下来，而搜索如果要返回了，则说明该次搜索已经结束，没有结果，应该把该记录去除。

* 堆栈溢出:步数太多内存不足. 可以判断一下，如果某条路走的步数超过100步，就不再走了，赶紧回退。

sample

~~~html
1 2 3
4 0 6
7 5 8
可以胜利,路径为:下 右
~~~

* 深搜: 深度优先搜索，会在一个方向一直搜下去，直到这条路走不通，才会考虑第二个方向。

* 广搜: 广度优先搜索，是先搜索每一个可行方向的第一步，然后再接着搜索每一个可行方向的第二步。以此类推。你可以认为有一波人在搜索,在每一个岔路口,都会分成多波在每一个方向分头行动进行搜索. **你可以将要搜索的初始状态加到一个队列里，然后每次从队列中取出一个状态，往可以前进的方向前进一步，然后再将该状态放到队列。利用队列先进先出的特点，就可以实现广搜的效果。**
