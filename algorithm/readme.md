## 时间复杂度

* n寸面包，每3天吃掉1寸，吃完要3n天，记作T(n)=3n
* n寸面包，每5天吃掉一半，剩1寸要5logn，记作T(n)=5logn
* n寸面包，每2天吃掉1个鸡腿，吃完鸡腿要2天，记作T(n)=2
* n寸面包，第1寸1天，第二个1寸2天，第三个1寸3天，吃完要1+2+3+...+n-1+n=0.5n^2+0.5n，记作T(n)=0.5n^2+0.5n

若存在函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于0的常数，则称f(n)是T(n)的同数量级函数。

记作T(n)=O(f(n))，称O(f(n))为算法的渐进时间复杂度，简称时间复杂度。

推导出时间复杂度的原则：

* 如果运行时间是常数量级，用常数1表示
* 只保留时间函数中的最高阶项
* 如果最高阶项存在，则省去最高阶项前面的系数

* T(n)=3n，时间复杂度为O(n)
* T(n)=5logn，O(logn)
* T(n)=2，O(1)
* T(n)=0.5n^2+0.5n，O(n^2)

* O(1)<O(logn)<O(n)<O(n^2)

## 快速排序

快速排序[O(nLogn)]是从冒泡排序[O(n^2)]演变而来的算法，但是比冒泡排序高效，使用了分治法。也属于交换排序。

冒泡排序在每一轮只把一个元素冒泡到数列的一端

快速排序在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比他小的元素移动到数列另一边，从而把数列拆解成了两个部分。

* 挖坑法
* 指针交换法


## 如何判断一个数是否在40亿个整数中？

* 一个整数4个字节,一个字节8位(1111 1111)
* 4字节x8位=32位(32个1), 4294967295(2^32-1)
* 10亿字节(1,000,000,000byte)为1G
* 40亿个整数,则40亿x4字节=160亿字节,即需要16G
* 判断一个数存在不存在只有两个状态,所以可以用一个位来代表
	* bitmap算法(大数据算法,用位来表示状态)
	* 2^32=4294967296,所以可以申请2^32个位
	* 一个字节8位,2^32/8(2^3)=536870912字节(2^29),即约500M空间即可

## 如何实现可以获取最小值的栈？

* 我现在需要实现一个栈，这个栈除了可以进行普通的push、pop操作以外，还可以进行getMin的操作，getMin方法被调用后，会返回当前栈的最小值，你会怎么做呢？你可以假设栈里面存的都是int整数。
* 一个data栈,一个mins辅助栈
* mins栈存依次入栈的最小值的索引
	* 2 1 2 3 4 1 1 1 6 依次入栈
		* data: 2 1 2 3 4 1 1 1 6
		* mins: 0 1
* push(2)
	* data: 2
	* mins: 0
* push(1)
	* data: 2 1
	* mins: 0 1
* push(1)
	* data: 2 1 1
	* mins: 0 1
* pop()
	* data: 2 1
	* mins: 0 1 (索引为2,mins不动)
* getMin()
	* mins栈顶为1,找data索引1的值1返回

## 热搜排行榜原型

每个被搜索的词条都是一个结构体，所有的被搜索词条构成了一个结构体数组，也就是一个线性结构。被搜索词条这个结构体中有两个成员变量，一个是用于存放搜索次数的整形变量sum，sum要被赋初值为0；另一个是用于存放关键词的字符串key。

将每次用户的输入分成两种情况，第一种情况是之前已经被搜索过的关键词，第二种情况则是之前从来没有被搜索过的关键词。若是第一种情况则让该词条的搜索次数自加1；若是第二种情况则要将新的用户输入作为新词条存储到由被搜索词条构成的结构体数组中，并让该新词条的搜索次数自加1，此时该新词条的搜索次数由初始化后的0变为1。

运用选择排序法或者其他排序算法根据搜索次数由多到少将词条进行排序
