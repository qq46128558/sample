## 时间复杂度

* n寸面包，每3天吃掉1寸，吃完要3n天，记作T(n)=3n
* n寸面包，每5天吃掉一半，剩1寸要5logn，记作T(n)=5logn
* n寸面包，每2天吃掉1个鸡腿，吃完鸡腿要2天，记作T(n)=2
* n寸面包，第1寸1天，第二个1寸2天，第三个1寸3天，吃完要1+2+3+...+n-1+n=0.5n^2+0.5n，记作T(n)=0.5n^2+0.5n

若存在函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于0的常数，则称f(n)是T(n)的同数量级函数。

记作T(n)=O(f(n))，称O(f(n))为算法的渐进时间复杂度，简称时间复杂度。

推导出时间复杂度的原则：

* 如果运行时间是常数量级，用常数1表示
* 只保留时间函数中的最高阶项
* 如果最高阶项存在，则省去最高阶项前面的系数

* T(n)=3n，时间复杂度为O(n)
* T(n)=5logn，O(logn)
* T(n)=2，O(1)
* T(n)=0.5n^2+0.5n，O(n^2)

* O(1)<O(logn)<O(n)<O(n^2)

## 快速排序

快速排序[O(nLogn)]是从冒泡排序[O(n^2)]演变而来的算法，但是比冒泡排序高效，使用了分治法。也属于交换排序。

冒泡排序在每一轮只把一个元素冒泡到数列的一端

快速排序在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比他小的元素移动到数列另一边，从而把数列拆解成了两个部分。

* 挖坑法
* 指针交换法


## 如何判断一个数是否在40亿个整数中？

* 一个整数4个字节,一个字节8位(1111 1111)
* 4字节x8位=32位(32个1), 4294967295(2^32-1)
* 10亿字节(1,000,000,000byte)为1G
* 40亿个整数,则40亿x4字节=160亿字节,即需要16G